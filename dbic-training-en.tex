\usepackage[english]{babel}
\usepackage{caption}
\captionsetup{labelformat=empty,labelsep=none}
\usepackage{verbatim}
\usepackage{listings}
\usepackage{ulem}
\lstset{language=Perl,basicstyle=\normalsize,tabsize=3,showstringspaces=false}

\title{DBIx::Class Training}
\author{Stefan Hornburg (Racke), Peter Mottram (SysPete)}
\date{Perl Dancer Conference 2015, Vienna, 20th October 2015}

\begin{document}
\maketitle

\input sponsors.tex

\begin{frame}
  \titlepage
\end{frame}

\cleardoublepage

\tableofcontents

\cleardoublepage

\section{Introduction}

\begin{frame}{SQL is ...}
\begin{itemize}
\item SQL is ... boring
\item SQL is ... complex
\item SQL is ... incompatible
\end{itemize}
\end{frame}

\section{Schema Classes}

\begin{frame}{Schema Classes}
\begin{itemize}
\item Country
\item User
\end{itemize}
\end{frame}

\subsection{Country Result Class}

\begin{frame}{Country / Vanilla DBIx::Class}

\end{frame}

\begin{frame}{Country / Candy DBIx::Class}

\end{frame}

\subsection{User Result Class}

\begin{frame}{User / Vanilla DBIx::Class}

\end{frame}

\begin{frame}{User / Candy DBIx::Class}

\end{frame}

\section{Basic and Advanced Queries}
\begin{frame}{Basic and Advanced Queries}
\end{frame}

\subsection{Correlated Subqueries}
\begin{frame}{Correlated Subqueries}
\end{frame}

\section{Using relationships}
\begin{frame}{Using relationships}
\end{frame}

\section{Extending Schema}
\begin{frame}{Extending Schema}
\end{frame}

\subsection{Helpers}
\subsubsection{ResultSet Helpers}
\begin{description}
\item[Me] 
simple exact way to set table aliases correctly in queries
\item[Random] small random subset
great for related product searches where you want a small 
random subset of the results
\item[CorrelateRelationship] 
makes correlated subqueries really simple
\end{description}

\begin{frame}{ResultSet Helpers}
\begin{description}
\item[Me] correct table aliases
\item[Random] small random subset
\item[CorrelateRelationship]  
\end{description}
\end{frame}

Problem: we want a count of rows in a related table

Obvious approach:

\begin{lstlisting}
    my $rs = $schema->resultset('Author')->search(
        undef,
        {
            join       => 'books',
            '+columns' => {
                book_count => {
                    count => 'books.id'
                }
            },
            distinct   => 1,    # let DBIC work out group_by for us
        }
    );
\end{lstlisting}

This causes a number of problems:

\begin{itemize}
\item Depending on engine, COUNT’s that aren’t COUNT(*) tend to be slow as
they do table scans.
\item This is hard to chain since we've introduced JOIN and GROUP BY and
collapsed COUNTs might produced unexpected results.
\end{itemize}

\begin{lstlisting}
Much nicer to do:

    package MyApp::Schema::ResultSet::Author;

    use parent 'DBIx::Class::ResultSet';

   
__PACKAGE__->load_components(qw(Helper::ResultSet::CorrelateRelationship));

    sub with_book_count {
        my $self = shift;

        $self->search(
            undef,
            {
                '+columns' => {
                    book_count =>
$self->correlate('books')->count_rs->as_query
                }
            }
        );
    }
\end{lstlisting}

Then elsewhere:

\begin{lstlisting}
my $rs = $schema->resultset('Author')->with_book_count;

The SQL query will look something like this:

  SELECT me.id, me.name, me.foo, ..., (
    SELECT COUNT( * )
      FROM books books_alias
     WHERE books_alias.id = authors.id
   )
  FROM authors me

This is *much* faster and *always* chainable since no JOIN, GROUP BY, or
other junk added to query.
\end{lstlisting}

Cool example from Interchange6::Schema::ResultSet::Product :

\begin{lstlisting}
    sub with_average_rating {
        my $self = shift;

        return $self->search(
            undef,
            {
                '+select' => [
                    {
                        coalesce => [

                            $self->correlate('canonical')
                              ->related_resultset('_product_reviews')
                              ->search_related(
                                'message',
                                { 'message.approved' => 1,
'message.public' => 1 }
                             
)->get_column('rating')->func_rs('avg')->as_query,

                            $self->correlate('_product_reviews')
                              ->search_related(
                                'message',
                                { 'message.approved' => 1,
'message.public' => 1 }
                             
)->get_column('rating')->func_rs('avg')->as_query,

                          ],
                        -as => 'average_rating'
                    }
                ],
                '+as' => ['average_rating'],
            }
        );
    }
\end{lstlisting}

\subsubsection{Shortcuts}
\begin{description}
\item[AddColumns] 
\item[Columns]
\item[Distinct]
\item[GroupBy] 
\item[HRI]
uses this all the time
\item[HasRows] much faster than count for very large resultsets
\item[Limit]
\item[OrderBy]
\item[Page]
\item[Prefetch]
\item[Rows]
\item[Search::{Not}Like]
\item[Search::{Not}Null] 
\end{description}

\subsubsection{Schema}
\begin{description}
\item[DateTime]
much simpler query construction for DateTime inflated fields
\item[QuoteNames] 
forces quote\_names even if someone misses it in their 
config yml - everyone should use this
\end{description}

\begin{frame}{Schema Helpers}
\begin{description}
\item[DateTime] DateTime inflated fields
\item[QuoteNames] forces quote\_names
\end{description}
\end{frame}

\section{Writing Tests}
\begin{frame}{Writing Tests}
\end{frame}

\section{Deployment Handler}
\begin{frame}{Deployment Handler}
\end{frame}

\end{document}

%%% Local Variables: 
%%% mode: latex
%%% TeX-master: t
%%% End: 
